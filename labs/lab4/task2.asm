.ORIG x3000			; Начало программы по адресу x3000

; Инициализация данных
LD R1, NUM1			; Загрузка первого числа в регистр R1
LD R2, NUM2			; Загрузка второго числа в регистр R2


; Сложение
	ADD R3, R1, R2		; R3 = R1 + R2
	LEA R0, SUM_MSG		; Загружаем адрес сообщения о сумме
	PUTS			; Выводим сообщение
	JSR PRINT_DEC		; Выводим результат сложения

; Вычитание
	AND R3, R3, #0 		; Обнуляем R3 для результата вычитания
	NOT R4, R2
	ADD R4, R4, #1		; R4 = -R2
	ADD R3, R1, R4		; R3 = R1 - R2
	LEA R0, SUB_MSG		; Загружаем адрес сообщения о вычитании
	PUTS
	JSR PRINT_DEC		; Выводим результат вычитания

; Умножение (простое сложение в цикле)
	AND R3, R3, #0 		; Обнуляем R3 для результата умножения
	AND R4, R4, #0		; R4 будет использоваться как счетчик
    	NOT R5, R2		;ADD R5, R5, #1 не увеличиваем!!!
	
MUL_LOOP
	ADD R4, R4, #1
	ADD R0, R4, R5
	BRz MUL_DONE 		; Если R4 достиг R2, заканчиваем умножение
	ADD R3, R3, R1		; Добавляем R1 к R3
	BRnzp MUL_LOOP
MUL_DONE
	LEA R0, MUL_MSG		; Загружаем адрес сообщения о умножении
	PUTS
	JSR PRINT_DEC		; Выводим результат умножения

; Деление (простое вычитание в цикле)
	AND R3, R3, #0		; R3 будет хранить частное
	AND R4, R4, #0		; R4 для временного хранения остатка
DIV_L
	NOT R4, R2		; R4 = -R2
	ADD R4, R4, #1		
	ADD R4, R1, R4  	; R4 = R1 - R2
	BRn DIV_D		; Если результат отрицательный, заканчиваем деление
	ADD R1, R4, #0		; Обновляем остаток
	ADD R3, R3, #1		; Увеличиваем частное
	BRnzp DIV_L
DIV_D
	LEA R0, DIV_MSG		; Загружаем адрес сообщения о делении
	PUTS
	JSR PRINT_DEC		; Выводим результат деления


    HALT

; Подпрограмма для вывода числа в десятичном формате
PRINT_DEC
	AND R0, R0, #0		; Очищаем R0
	LD R4, ASCII_OFFSET	; Загружаем смещение для перевода числа в ASCII
	LD R5, TEN		; Загружаем значение 10 в R5
	AND R6, R6, #0		; Очищаем R6 (счетчик цифр)
	LEA R7, BUFFER		; Загружаем адрес буфера для хранения цифр

DIGIT_LOOP
	ADD R0, R3, #-10	; Проверяем, больше ли R3 10
	BRn DIGIT_DONE		; Если меньше, переходим к завершению
	ADD R3, R3, #-10	; Вычитаем 10 из R3
	ADD R6, R6, #1		; Увеличиваем счетчик цифр
	BRnzp DIGIT_LOOP	; Повторяем

DIGIT_DONE
	ADD R0, R3, R4		; Преобразуем остаток в ASCII
	STR R0, R7, #0		; Сохраняем символ в буфер
	ADD R7, R7, #1		; Переходим к следующей ячейке буфера

	ADD R3, R6, #0		; Переключаемся на целую часть
	BRz OUTPUT_LOOP		; Если целая часть равна нулю, переходим к выводу

	ADD R0, R3, R4		; Преобразуем целую часть в ASCII
	STR R0, R7, #0 		; Сохраняем символ в буфер
	ADD R7, R7, #1 		; Переходим к следующей ячейке буфера
	BRnzp OUTPUT_LOOP	; Переходим к выводу

OUTPUT_LOOP
	ADD R7, R7, #-1		; Возвращаемся к предыдущей ячейке буфера
	LDR R0, R7, #0		; Загружаем символ из буфера
	OUT			; Выводим символ
	BRnp OUTPUT_LOOP	; Повторяем, пока не выведем все символы

	RET			; Возвращаемся из подпрограммы

; Данные
NUM1 .FILL x000A		; Первое число 
NUM2 .FILL x0005		; Второе число 
ASCII_OFFSET .FILL x0030	; Смещение для перевода числа в ASCII (символ '0')
TEN  .FILL x000A		; Число 10 для деления
BUFFER .BLKW 10			; Буфер для хранения цифр (максимум 10 цифр)
SUM_MSG .STRINGZ "Sum: "
SUB_MSG .STRINGZ "Sub: "
MUL_MSG .STRINGZ "Mul: "
DIV_MSG .STRINGZ "Div: "
EOL .STRINGZ "\n"		; Конец строки

.END				; Конец программы
