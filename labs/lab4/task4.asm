.ORIG x3000

; Инициализация данных
LD R2, INIT			; Счетчик введенных чисел
LEA R1, ARRAY			; Адрес массива для хранения чисел

; Ввод данных
INPUT_LOOP
	ADD R2, R2, #1		; Увеличиваем счетчик
	LEA R0, MSG		; Загружаем строку запроса
	PUTS			; Выводим запрос

	GETC 			; Получаем символ ввода
	OUT			; Отображаем введенный символ

	ADD R3, R0, #0		; Копируем символ в R3
	LD R4, NEG_ASCII_ZERO	; Загрузка -48 в R4 для преобразования ASCII
	ADD R3, R3, R4		; Преобразуем символ в число
	STR R3, R1, #0		; Сохраняем число в массив
	ADD R1, R1, #1 		; Увеличиваем адрес массива

	LEA R0, NEWLINE		; Загружаем символ новой строки
	PUTS			; Выводим новую строку

	ADD R3, R2, #-5		; Проверяем, введено ли 5 чисел
	BRz BUBBLE_SORT		; Переход к сортировке, если да
	BRnzp INPUT_LOOP 	; Иначе продолжаем ввод

; Сортировка
BUBBLE_SORT
	LD R6, ARRAY_LEN 	; Загружаем длину массива
	ADD R4, R6, #0 		; Копируем длину массива в R4

OUTER_LOOP
	ADD R4, R4, #-1 	; Уменьшаем счетчик проходов
	BRz OUTPUT_LOOP		; Если счетчик равен 0, переходим к выводу
	LEA R3, ARRAY		; Загружаем адрес начала массива
	ADD R5, R4, #0		; Копируем R4 в R5 для внутреннего цикла

INNER_LOOP
	LDR R0, R3, #0		; Загружаем текущий элемент массива
	LDR R1, R3, #1 		; Загружаем следующий элемент массива

	; Проверка: Если R0 > R1, меняем местами
	NOT R2, R1
	ADD R2, R2, #1
	ADD R2, R0, R2 		; R2 = R0 - R1
	BRn SWAP		; Если положительное, меняем местами

SKIP_SWAP
	ADD R3, R3, #1 		; Переходим к следующему элементу
	ADD R5, R5, #-1 	; Уменьшаем внутренний счетчик
	BRp INNER_LOOP		; Продолжаем, пока R5 > 0
	BRnzp OUTER_LOOP	; Возвращаемся к внешнему циклу

SWAP
	STR R1, R3, #0 		; Меняем местами элементы
	STR R0, R3, #1
	BRnzp SKIP_SWAP		; Переходим к следующему элементу

; Вывод данных
OUTPUT_LOOP
	LEA R1, ARRAY		; Сбрасываем адрес начала массива
	LD R2, INIT		; Сбрасываем счетчик элементов

PRINT_LOOP
	LDR R0, R1, #0		; Загружаем элемент массива
	LD R4, ASCII_ZERO	; Загружаем ASCII-код '0'
	ADD R0, R0, R4		; Преобразуем число обратно в ASCII
	OUT			; Выводим символ

	LEA R0, NEWLINE		; Загружаем символ новой строки
	PUTS			; Выводим новую строку

	ADD R1, R1, #1		; Переходим к следующему элементу
	ADD R2, R2, #1		; Увеличиваем счетчик
	ADD R3, R2, #-5	; Проверяем, достигнут ли лимит
	BRz END			; Если да, заканчиваем
	BRnzp PRINT_LOOP	; Иначе продолжаем вывод

; Завершение программы
END
    HALT			; Останавливаем выполнение

; Данные
INIT .FILL #0			; Инициализация счетчика
MSG .STRINGZ "Enter a number: "	; Сообщение для ввода
NEWLINE .STRINGZ "\n"		; Символ новой строки
ASCII_ZERO .FILL #48		; ASCII-код '0'
NEG_ASCII_ZERO .FILL #-48	; Чтобы вычесть 48 (ASCII '0')
ARRAY .BLKW #5			; Буфер для массива (5 чисел)
ARRAY_LEN .FILL #5		; Длина массива

.END 				; Конец программы
